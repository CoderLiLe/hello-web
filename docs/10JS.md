

## 1 JavaScript 中的垃圾回收机制（GC）

### 1.1 垃圾回收相关概念

#### ① 什么是垃圾

```
1. 用不到的数据，就是垃圾
2. JavaScript 中没有被引用的对象，就是垃圾对象
```

#### ② 什么是垃圾回收

```
1. 销毁垃圾对象，释放内存，就是垃圾回收
2. 需要手动垃圾回收的编程语言： C、C++
3. 自动垃圾回收的编程语言： Java、Python、JS 等
```

#### ③ 垃圾没有及时回收的后果

```
垃圾没有及时回收造成内存泄漏，越来越多的内存泄漏会导致内存溢出
```

**内存溢出：** 需要使用内存的时候，内存空间不够。

**内存泄漏：** 垃圾没有回收称为内存泄漏。

#### ④ JavaScript 垃圾回收的常见算法

```
- 引用计数
- 标记清除
```

### 1.2 引用计数

#### ① 原理

```
- ① 对象有个引用标记
- ② 如果对对象进行了引用 +1
- ③ 取消了对象对象的引用 -1
- ④ 当引用标记=0的时候，变为垃圾对象，并删除
```

#### ② 优缺点：

```
- 优点： 及时清除垃圾对象
- 缺点： 互相引用的对象导致无法被回收（内存泄漏）
```

### 1.3 标记清除

#### ① 原理

```
浏览器不停地进行标记清除，每一轮分为标记和清除两个阶段
- 标记阶段：从根对象出发，每一个可以从根对象访问到的对象都会被添加一个标记，于是这个对象就被标识为可到达对象。
- 清除阶段：垃圾回收器，会对内存从头到尾进行线性遍历，如果发现有对象没有被标记为可到达对象，那么就将此对象占用的内存回收。
该轮结束，将原来标记为清除，以便进行下一轮标记清除。
```

#### ② 优缺点

```
- 优点：  不会内存泄漏
- 缺点：  需要深度递归，耗费资源较多
```



## 2 执行上下文和执行栈

### 2.1 执行上下文

#### ① 全局执行上下文

```
1. 打开页面，js代码执行之前，创建 window 对象，确定 window 就是全局执行上下文对象
2. 对全局执行上下文对象进行预处理
   ① 找到使用 var 的变量声明语句，给全局执行上下文对象添加属性，但不赋值
   ② 找到使用 function 的函数声明语句，给全局执行上下文对象添加属性，值是函数
   ③ 给 this 进行赋值，将全局执行上下文对象赋值给 this
3. 正式执行全局代码
4. 页面关闭，全局执行上下文对象销毁
```

#### ② 函数内的执行上下文

```
1. 调用函数的时候，函数内代码执行之前，创建该函数的执行上下文对象；
2. 对函数内执行上下文对象进行预处理
   ① 将形参作为函数内执行上下文对象的属性，并赋值
   ② 给函数内执行上下文对象添加属性arguments，并赋值
   ③ 找到函数内使用 var 的变量声明语句，给函数内执行上下文对象添加属性，不赋值
   ④ 找到函数内使用 function 的函数声明语句，给函数内执行上下文对象添加属性，值是函数
   ④ 给 this 进行赋值，将调用该函数的对象赋值给 this
3. 正式执行函数内的语句
4. 函数调用结束，函数内执行上下文对象被销毁
```

> **注意：** 函数每调用一次，就创建一个执行上下文对象。

### 2.2 执行栈

**栈结构：** 是一种数据存储结构，特点先进后出，后进先出。

**执行栈：**执行上下文对象创建之后，要放入执行栈，放入执行栈才能执行。

### 2.3 作用域和执行上下文的关系

**区别：**

```
1. 变量的作用域在函数声明的时候就确定了，是静态的
2. 执行上下文对象函数调用的时候才创建，每调用一次就创建一次，调用结束会销毁，是动态的
```

**联系：**

```
执行上下文对象从属于所在的作用域：
全局执行上下文对象作用域是全局； 函数内执行上下文对象作用域是所在函数。
```



## 3. 闭包

### 3.1 什么是闭包？

```
1）简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。
2）MDN 上面这么说：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。
```

### 3.2 如何产生闭包

```
1. 函数A中嵌套函数B
2. 函数B中访问函数A中定义的数据（上层作用域的变量）
3. 实现从函数A的外部使用函数B
   方式一： 将函数B作为返回值
   方式二： 将函数B赋值给全局对象的属性
   方式三： 将函数B作为一个事件的回调函数
```

```js
function A() {
    // 定义数据
    var num01 = 100, num02 = 200;
    // 函数B
    function B(){
        // 函数B中可以访问到函数A中的数据
        console.log(num01 + num02);
    }
    // 方式一 函数B作为返回值
    return B;

    // 方式二 函数B赋值给全局对象的属性
    // window.func = B;

    // 方式三 函数B作为事件的回调函数
    // document.onclick = B;
}
```

### 3.3 闭包和作用域

```
1. 可以访问上层作用域的数据
2. 作用域只与函数声明的位置有关，与调用位置无关
```

### 3.4 闭包和垃圾回收

```
闭包延长了数据的生命周期
```

### 3.5 闭包的缺点

```
闭包会让数据常驻内存，增加了内存溢出的风险
```

### 3.6 闭包的应用

```js
 for (var i = 0; i < tabNavItems.length; i ++) {
     (function(index){
         tabNavItems[index].onclick = function() {
             // 排他
             // 把所有的tabNav都取消选中  把所有的tabContent隐藏
             for (var j = 0; j < tabNavItems.length; j ++) {
                 tabNavItems[j].classList.remove('active');
                 tabContentItems[j].classList.remove('active');
             }

             // 当前点击的选项卡导航添加 active 类名 表示当前选中
             this.classList.add('active');
             // 与当前tabNav对应的tabContent要显示出来
             tabContentItems[index].classList.add('active');
         };
     })(i);
 }
```